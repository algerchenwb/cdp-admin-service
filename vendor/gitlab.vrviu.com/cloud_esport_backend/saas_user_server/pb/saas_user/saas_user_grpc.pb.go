// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.19.4
// source: saas_user.proto

package saas_user

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	DemoService_Ping_FullMethodName = "/saas_user.DemoService/Ping"
)

// DemoServiceClient is the client API for DemoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DemoServiceClient interface {
	Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error)
}

type demoServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDemoServiceClient(cc grpc.ClientConnInterface) DemoServiceClient {
	return &demoServiceClient{cc}
}

func (c *demoServiceClient) Ping(ctx context.Context, in *Request, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, DemoService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DemoServiceServer is the server API for DemoService service.
// All implementations must embed UnimplementedDemoServiceServer
// for forward compatibility
type DemoServiceServer interface {
	Ping(context.Context, *Request) (*Response, error)
	mustEmbedUnimplementedDemoServiceServer()
}

// UnimplementedDemoServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDemoServiceServer struct {
}

func (UnimplementedDemoServiceServer) Ping(context.Context, *Request) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDemoServiceServer) mustEmbedUnimplementedDemoServiceServer() {}

// UnsafeDemoServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DemoServiceServer will
// result in compilation errors.
type UnsafeDemoServiceServer interface {
	mustEmbedUnimplementedDemoServiceServer()
}

func RegisterDemoServiceServer(s grpc.ServiceRegistrar, srv DemoServiceServer) {
	s.RegisterService(&DemoService_ServiceDesc, srv)
}

func _DemoService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DemoServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DemoService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DemoServiceServer).Ping(ctx, req.(*Request))
	}
	return interceptor(ctx, in, info, handler)
}

// DemoService_ServiceDesc is the grpc.ServiceDesc for DemoService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DemoService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "saas_user.DemoService",
	HandlerType: (*DemoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _DemoService_Ping_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas_user.proto",
}

const (
	UserService_GetUserInfoList_FullMethodName = "/saas_user.UserService/GetUserInfoList"
	UserService_UpdateUserInfo_FullMethodName  = "/saas_user.UserService/UpdateUserInfo"
	UserService_GetUserInfo_FullMethodName     = "/saas_user.UserService/GetUserInfo"
	UserService_CreateUserInfo_FullMethodName  = "/saas_user.UserService/CreateUserInfo"
	UserService_DeleteUserInfo_FullMethodName  = "/saas_user.UserService/DeleteUserInfo"
)

// UserServiceClient is the client API for UserService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserServiceClient interface {
	GetUserInfoList(ctx context.Context, in *GetUserInfoListReq, opts ...grpc.CallOption) (*GetUserInfoListResp, error)
	UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResp, error)
	GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error)
	CreateUserInfo(ctx context.Context, in *CreateUserInfoReq, opts ...grpc.CallOption) (*CreateUserInfoResp, error)
	DeleteUserInfo(ctx context.Context, in *DeleteUserInfoReq, opts ...grpc.CallOption) (*DeleteUserInfoResp, error)
}

type userServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserServiceClient(cc grpc.ClientConnInterface) UserServiceClient {
	return &userServiceClient{cc}
}

func (c *userServiceClient) GetUserInfoList(ctx context.Context, in *GetUserInfoListReq, opts ...grpc.CallOption) (*GetUserInfoListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInfoListResp)
	err := c.cc.Invoke(ctx, UserService_GetUserInfoList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) UpdateUserInfo(ctx context.Context, in *UpdateUserInfoReq, opts ...grpc.CallOption) (*UpdateUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateUserInfoResp)
	err := c.cc.Invoke(ctx, UserService_UpdateUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) GetUserInfo(ctx context.Context, in *GetUserInfoReq, opts ...grpc.CallOption) (*GetUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetUserInfoResp)
	err := c.cc.Invoke(ctx, UserService_GetUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) CreateUserInfo(ctx context.Context, in *CreateUserInfoReq, opts ...grpc.CallOption) (*CreateUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateUserInfoResp)
	err := c.cc.Invoke(ctx, UserService_CreateUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userServiceClient) DeleteUserInfo(ctx context.Context, in *DeleteUserInfoReq, opts ...grpc.CallOption) (*DeleteUserInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteUserInfoResp)
	err := c.cc.Invoke(ctx, UserService_DeleteUserInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServiceServer is the server API for UserService service.
// All implementations must embed UnimplementedUserServiceServer
// for forward compatibility
type UserServiceServer interface {
	GetUserInfoList(context.Context, *GetUserInfoListReq) (*GetUserInfoListResp, error)
	UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResp, error)
	GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error)
	CreateUserInfo(context.Context, *CreateUserInfoReq) (*CreateUserInfoResp, error)
	DeleteUserInfo(context.Context, *DeleteUserInfoReq) (*DeleteUserInfoResp, error)
	mustEmbedUnimplementedUserServiceServer()
}

// UnimplementedUserServiceServer must be embedded to have forward compatible implementations.
type UnimplementedUserServiceServer struct {
}

func (UnimplementedUserServiceServer) GetUserInfoList(context.Context, *GetUserInfoListReq) (*GetUserInfoListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfoList not implemented")
}
func (UnimplementedUserServiceServer) UpdateUserInfo(context.Context, *UpdateUserInfoReq) (*UpdateUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserInfo not implemented")
}
func (UnimplementedUserServiceServer) GetUserInfo(context.Context, *GetUserInfoReq) (*GetUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserInfo not implemented")
}
func (UnimplementedUserServiceServer) CreateUserInfo(context.Context, *CreateUserInfoReq) (*CreateUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserInfo not implemented")
}
func (UnimplementedUserServiceServer) DeleteUserInfo(context.Context, *DeleteUserInfoReq) (*DeleteUserInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserInfo not implemented")
}
func (UnimplementedUserServiceServer) mustEmbedUnimplementedUserServiceServer() {}

// UnsafeUserServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServiceServer will
// result in compilation errors.
type UnsafeUserServiceServer interface {
	mustEmbedUnimplementedUserServiceServer()
}

func RegisterUserServiceServer(s grpc.ServiceRegistrar, srv UserServiceServer) {
	s.RegisterService(&UserService_ServiceDesc, srv)
}

func _UserService_GetUserInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfoList(ctx, req.(*GetUserInfoListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_UpdateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).UpdateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_UpdateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).UpdateUserInfo(ctx, req.(*UpdateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_GetUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).GetUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_GetUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).GetUserInfo(ctx, req.(*GetUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_CreateUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).CreateUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_CreateUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).CreateUserInfo(ctx, req.(*CreateUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserService_DeleteUserInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServiceServer).DeleteUserInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserService_DeleteUserInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServiceServer).DeleteUserInfo(ctx, req.(*DeleteUserInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserService_ServiceDesc is the grpc.ServiceDesc for UserService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "saas_user.UserService",
	HandlerType: (*UserServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUserInfoList",
			Handler:    _UserService_GetUserInfoList_Handler,
		},
		{
			MethodName: "UpdateUserInfo",
			Handler:    _UserService_UpdateUserInfo_Handler,
		},
		{
			MethodName: "GetUserInfo",
			Handler:    _UserService_GetUserInfo_Handler,
		},
		{
			MethodName: "CreateUserInfo",
			Handler:    _UserService_CreateUserInfo_Handler,
		},
		{
			MethodName: "DeleteUserInfo",
			Handler:    _UserService_DeleteUserInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas_user.proto",
}

const (
	AgentService_GetAgentInfo_FullMethodName     = "/saas_user.AgentService/GetAgentInfo"
	AgentService_GetAgentInfoList_FullMethodName = "/saas_user.AgentService/GetAgentInfoList"
	AgentService_CreateAgentInfo_FullMethodName  = "/saas_user.AgentService/CreateAgentInfo"
	AgentService_UpdateAgentInfo_FullMethodName  = "/saas_user.AgentService/UpdateAgentInfo"
	AgentService_DeleteAgentInfo_FullMethodName  = "/saas_user.AgentService/DeleteAgentInfo"
)

// AgentServiceClient is the client API for AgentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AgentServiceClient interface {
	GetAgentInfo(ctx context.Context, in *GetAgentInfoReq, opts ...grpc.CallOption) (*GetAgentInfoResp, error)
	GetAgentInfoList(ctx context.Context, in *GetAgentInfoListReq, opts ...grpc.CallOption) (*GetAgentInfoListResp, error)
	CreateAgentInfo(ctx context.Context, in *CreateAgentInfoReq, opts ...grpc.CallOption) (*CreateAgentInfoResp, error)
	UpdateAgentInfo(ctx context.Context, in *UpdateAgentInfoReq, opts ...grpc.CallOption) (*UpdateAgentInfoResp, error)
	DeleteAgentInfo(ctx context.Context, in *DeleteAgentInfoReq, opts ...grpc.CallOption) (*DeleteAgentInfoResp, error)
}

type agentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewAgentServiceClient(cc grpc.ClientConnInterface) AgentServiceClient {
	return &agentServiceClient{cc}
}

func (c *agentServiceClient) GetAgentInfo(ctx context.Context, in *GetAgentInfoReq, opts ...grpc.CallOption) (*GetAgentInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentInfoResp)
	err := c.cc.Invoke(ctx, AgentService_GetAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) GetAgentInfoList(ctx context.Context, in *GetAgentInfoListReq, opts ...grpc.CallOption) (*GetAgentInfoListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAgentInfoListResp)
	err := c.cc.Invoke(ctx, AgentService_GetAgentInfoList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) CreateAgentInfo(ctx context.Context, in *CreateAgentInfoReq, opts ...grpc.CallOption) (*CreateAgentInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateAgentInfoResp)
	err := c.cc.Invoke(ctx, AgentService_CreateAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) UpdateAgentInfo(ctx context.Context, in *UpdateAgentInfoReq, opts ...grpc.CallOption) (*UpdateAgentInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateAgentInfoResp)
	err := c.cc.Invoke(ctx, AgentService_UpdateAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *agentServiceClient) DeleteAgentInfo(ctx context.Context, in *DeleteAgentInfoReq, opts ...grpc.CallOption) (*DeleteAgentInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteAgentInfoResp)
	err := c.cc.Invoke(ctx, AgentService_DeleteAgentInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AgentServiceServer is the server API for AgentService service.
// All implementations must embed UnimplementedAgentServiceServer
// for forward compatibility
type AgentServiceServer interface {
	GetAgentInfo(context.Context, *GetAgentInfoReq) (*GetAgentInfoResp, error)
	GetAgentInfoList(context.Context, *GetAgentInfoListReq) (*GetAgentInfoListResp, error)
	CreateAgentInfo(context.Context, *CreateAgentInfoReq) (*CreateAgentInfoResp, error)
	UpdateAgentInfo(context.Context, *UpdateAgentInfoReq) (*UpdateAgentInfoResp, error)
	DeleteAgentInfo(context.Context, *DeleteAgentInfoReq) (*DeleteAgentInfoResp, error)
	mustEmbedUnimplementedAgentServiceServer()
}

// UnimplementedAgentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedAgentServiceServer struct {
}

func (UnimplementedAgentServiceServer) GetAgentInfo(context.Context, *GetAgentInfoReq) (*GetAgentInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentInfo not implemented")
}
func (UnimplementedAgentServiceServer) GetAgentInfoList(context.Context, *GetAgentInfoListReq) (*GetAgentInfoListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAgentInfoList not implemented")
}
func (UnimplementedAgentServiceServer) CreateAgentInfo(context.Context, *CreateAgentInfoReq) (*CreateAgentInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateAgentInfo not implemented")
}
func (UnimplementedAgentServiceServer) UpdateAgentInfo(context.Context, *UpdateAgentInfoReq) (*UpdateAgentInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAgentInfo not implemented")
}
func (UnimplementedAgentServiceServer) DeleteAgentInfo(context.Context, *DeleteAgentInfoReq) (*DeleteAgentInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAgentInfo not implemented")
}
func (UnimplementedAgentServiceServer) mustEmbedUnimplementedAgentServiceServer() {}

// UnsafeAgentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AgentServiceServer will
// result in compilation errors.
type UnsafeAgentServiceServer interface {
	mustEmbedUnimplementedAgentServiceServer()
}

func RegisterAgentServiceServer(s grpc.ServiceRegistrar, srv AgentServiceServer) {
	s.RegisterService(&AgentService_ServiceDesc, srv)
}

func _AgentService_GetAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentInfo(ctx, req.(*GetAgentInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_GetAgentInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentInfoListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).GetAgentInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_GetAgentInfoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).GetAgentInfoList(ctx, req.(*GetAgentInfoListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_CreateAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAgentInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).CreateAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_CreateAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).CreateAgentInfo(ctx, req.(*CreateAgentInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_UpdateAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAgentInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).UpdateAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_UpdateAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).UpdateAgentInfo(ctx, req.(*UpdateAgentInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AgentService_DeleteAgentInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAgentInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AgentServiceServer).DeleteAgentInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AgentService_DeleteAgentInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AgentServiceServer).DeleteAgentInfo(ctx, req.(*DeleteAgentInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AgentService_ServiceDesc is the grpc.ServiceDesc for AgentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AgentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "saas_user.AgentService",
	HandlerType: (*AgentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAgentInfo",
			Handler:    _AgentService_GetAgentInfo_Handler,
		},
		{
			MethodName: "GetAgentInfoList",
			Handler:    _AgentService_GetAgentInfoList_Handler,
		},
		{
			MethodName: "CreateAgentInfo",
			Handler:    _AgentService_CreateAgentInfo_Handler,
		},
		{
			MethodName: "UpdateAgentInfo",
			Handler:    _AgentService_UpdateAgentInfo_Handler,
		},
		{
			MethodName: "DeleteAgentInfo",
			Handler:    _AgentService_DeleteAgentInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas_user.proto",
}

const (
	PrimaryService_GetPrimaryInfo_FullMethodName     = "/saas_user.PrimaryService/GetPrimaryInfo"
	PrimaryService_GetPrimaryInfoList_FullMethodName = "/saas_user.PrimaryService/GetPrimaryInfoList"
	PrimaryService_UpdatePrimaryInfo_FullMethodName  = "/saas_user.PrimaryService/UpdatePrimaryInfo"
	PrimaryService_CreatePrimaryInfo_FullMethodName  = "/saas_user.PrimaryService/CreatePrimaryInfo"
	PrimaryService_DeletePrimaryInfo_FullMethodName  = "/saas_user.PrimaryService/DeletePrimaryInfo"
)

// PrimaryServiceClient is the client API for PrimaryService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PrimaryServiceClient interface {
	GetPrimaryInfo(ctx context.Context, in *GetPrimaryInfoReq, opts ...grpc.CallOption) (*GetPrimaryInfoResp, error)
	GetPrimaryInfoList(ctx context.Context, in *GetPrimaryInfoListReq, opts ...grpc.CallOption) (*GetPrimaryInfoListResp, error)
	UpdatePrimaryInfo(ctx context.Context, in *UpdatePrimaryInfoReq, opts ...grpc.CallOption) (*UpdatePrimaryInfoResp, error)
	CreatePrimaryInfo(ctx context.Context, in *CreatePrimaryInfoReq, opts ...grpc.CallOption) (*CreatePrimaryInfoResp, error)
	DeletePrimaryInfo(ctx context.Context, in *DeletePrimaryInfoReq, opts ...grpc.CallOption) (*DeletePrimaryInfoResp, error)
}

type primaryServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPrimaryServiceClient(cc grpc.ClientConnInterface) PrimaryServiceClient {
	return &primaryServiceClient{cc}
}

func (c *primaryServiceClient) GetPrimaryInfo(ctx context.Context, in *GetPrimaryInfoReq, opts ...grpc.CallOption) (*GetPrimaryInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrimaryInfoResp)
	err := c.cc.Invoke(ctx, PrimaryService_GetPrimaryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *primaryServiceClient) GetPrimaryInfoList(ctx context.Context, in *GetPrimaryInfoListReq, opts ...grpc.CallOption) (*GetPrimaryInfoListResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPrimaryInfoListResp)
	err := c.cc.Invoke(ctx, PrimaryService_GetPrimaryInfoList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *primaryServiceClient) UpdatePrimaryInfo(ctx context.Context, in *UpdatePrimaryInfoReq, opts ...grpc.CallOption) (*UpdatePrimaryInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdatePrimaryInfoResp)
	err := c.cc.Invoke(ctx, PrimaryService_UpdatePrimaryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *primaryServiceClient) CreatePrimaryInfo(ctx context.Context, in *CreatePrimaryInfoReq, opts ...grpc.CallOption) (*CreatePrimaryInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreatePrimaryInfoResp)
	err := c.cc.Invoke(ctx, PrimaryService_CreatePrimaryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *primaryServiceClient) DeletePrimaryInfo(ctx context.Context, in *DeletePrimaryInfoReq, opts ...grpc.CallOption) (*DeletePrimaryInfoResp, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeletePrimaryInfoResp)
	err := c.cc.Invoke(ctx, PrimaryService_DeletePrimaryInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PrimaryServiceServer is the server API for PrimaryService service.
// All implementations must embed UnimplementedPrimaryServiceServer
// for forward compatibility
type PrimaryServiceServer interface {
	GetPrimaryInfo(context.Context, *GetPrimaryInfoReq) (*GetPrimaryInfoResp, error)
	GetPrimaryInfoList(context.Context, *GetPrimaryInfoListReq) (*GetPrimaryInfoListResp, error)
	UpdatePrimaryInfo(context.Context, *UpdatePrimaryInfoReq) (*UpdatePrimaryInfoResp, error)
	CreatePrimaryInfo(context.Context, *CreatePrimaryInfoReq) (*CreatePrimaryInfoResp, error)
	DeletePrimaryInfo(context.Context, *DeletePrimaryInfoReq) (*DeletePrimaryInfoResp, error)
	mustEmbedUnimplementedPrimaryServiceServer()
}

// UnimplementedPrimaryServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPrimaryServiceServer struct {
}

func (UnimplementedPrimaryServiceServer) GetPrimaryInfo(context.Context, *GetPrimaryInfoReq) (*GetPrimaryInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrimaryInfo not implemented")
}
func (UnimplementedPrimaryServiceServer) GetPrimaryInfoList(context.Context, *GetPrimaryInfoListReq) (*GetPrimaryInfoListResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPrimaryInfoList not implemented")
}
func (UnimplementedPrimaryServiceServer) UpdatePrimaryInfo(context.Context, *UpdatePrimaryInfoReq) (*UpdatePrimaryInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrimaryInfo not implemented")
}
func (UnimplementedPrimaryServiceServer) CreatePrimaryInfo(context.Context, *CreatePrimaryInfoReq) (*CreatePrimaryInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePrimaryInfo not implemented")
}
func (UnimplementedPrimaryServiceServer) DeletePrimaryInfo(context.Context, *DeletePrimaryInfoReq) (*DeletePrimaryInfoResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePrimaryInfo not implemented")
}
func (UnimplementedPrimaryServiceServer) mustEmbedUnimplementedPrimaryServiceServer() {}

// UnsafePrimaryServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PrimaryServiceServer will
// result in compilation errors.
type UnsafePrimaryServiceServer interface {
	mustEmbedUnimplementedPrimaryServiceServer()
}

func RegisterPrimaryServiceServer(s grpc.ServiceRegistrar, srv PrimaryServiceServer) {
	s.RegisterService(&PrimaryService_ServiceDesc, srv)
}

func _PrimaryService_GetPrimaryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrimaryInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrimaryServiceServer).GetPrimaryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrimaryService_GetPrimaryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrimaryServiceServer).GetPrimaryInfo(ctx, req.(*GetPrimaryInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrimaryService_GetPrimaryInfoList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPrimaryInfoListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrimaryServiceServer).GetPrimaryInfoList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrimaryService_GetPrimaryInfoList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrimaryServiceServer).GetPrimaryInfoList(ctx, req.(*GetPrimaryInfoListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrimaryService_UpdatePrimaryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePrimaryInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrimaryServiceServer).UpdatePrimaryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrimaryService_UpdatePrimaryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrimaryServiceServer).UpdatePrimaryInfo(ctx, req.(*UpdatePrimaryInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrimaryService_CreatePrimaryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePrimaryInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrimaryServiceServer).CreatePrimaryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrimaryService_CreatePrimaryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrimaryServiceServer).CreatePrimaryInfo(ctx, req.(*CreatePrimaryInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _PrimaryService_DeletePrimaryInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePrimaryInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PrimaryServiceServer).DeletePrimaryInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PrimaryService_DeletePrimaryInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PrimaryServiceServer).DeletePrimaryInfo(ctx, req.(*DeletePrimaryInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

// PrimaryService_ServiceDesc is the grpc.ServiceDesc for PrimaryService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PrimaryService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "saas_user.PrimaryService",
	HandlerType: (*PrimaryServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPrimaryInfo",
			Handler:    _PrimaryService_GetPrimaryInfo_Handler,
		},
		{
			MethodName: "GetPrimaryInfoList",
			Handler:    _PrimaryService_GetPrimaryInfoList_Handler,
		},
		{
			MethodName: "UpdatePrimaryInfo",
			Handler:    _PrimaryService_UpdatePrimaryInfo_Handler,
		},
		{
			MethodName: "CreatePrimaryInfo",
			Handler:    _PrimaryService_CreatePrimaryInfo_Handler,
		},
		{
			MethodName: "DeletePrimaryInfo",
			Handler:    _PrimaryService_DeletePrimaryInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "saas_user.proto",
}
